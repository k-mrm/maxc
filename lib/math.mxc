let {
    pi = 3.1415926535897932385;
    e = 2.7182818284590452353;
}

// *は未実装
// 三角関数
// sin(), cos(), tan(), asin(), acos(), atan()

// 双曲線関数
// sinh(), cosh(), tanh(), *asinh(), *acosh(), *atanh()

// 指数関数, 対数関数
// exp(), exp2(), log(), log10(), log2()

// 仮数, 指数
// ldexp(), *frexp(), *modf(), logb()

// 累乗, 冪根, 絶対値
// pow(), sqrt(), cbrt(), hypot(), abs(), fabs()

// 最近傍整数
// ceil(), floor(), round()

// 線形補間
// lerp()

// そのうちalgorithmライブラリに移行しそう
// min(), max()

def fabs(x: float) = if x >= 0.0 x else -x;

def abs(i: int) = if i >= 0 i else -i;

def ceil(x: float) = if x <= 0.0 toint(x) else -toint(-x - 1.0);

def floor(x: float) = if x >= 0.0 toint(x) else -toint(-x + 1.0);

def round(x: float) = floor(x + 0.5);

def max(x: float, y: float) = if x > y x else y;

def min(x: float, y: float) = if x < y x else y;

def __cos(x: float): float {
    let {
        c2 = 0.5;
        c4 = 0.041666666666666664;
        c6 = 0.001388888888888889;
        x2 = x * x;
        before = 1.0 - x2 * (c2 - x2 * c4);
        after = 1.0 - x2 * (c2 - x2 * (c4 - x2 * c6));
        d = before - after;
        n = 4.0;
        s = 1.0;
        f = 40320.0;
        x4 = x2 * x2;
        xx = x4 * x4;
    }
    while d > 0.0000000000000001 {
        before = after;
        after = after + s * xx / f;
        s = -s;
        xx = xx * x2;
        n = n + 1.0;
        f = f * 2.0 * n * (2.0 * n - 1.0);
        d = before - after;
        if(d < 0.0) {
            d = -d;
        }
    }
    return after;
}

def sin(x: float): float {
    let sign = 1.0;
    let pi2 = pi * 2.0;
    if fabs(x) > pi2 {
        x = x % pi2;
    }
    if fabs(x) > pi {
        sign = -sign;
        x = pi2 - x;
    }
    let piHalf = pi * 0.5;
    let rounding_error = 0.0000000000000001;
    if fabs(x) > piHalf {
        x = pi - x + rounding_error;
    }
    if fabs(x) > pi * 0.25 {
        return sign * __cos(piHalf - x + rounding_error);
    }
    let {
        s3 = 0.16666666666666666;
        s5 = 0.008333333333333333;
        s7 = 0.0001984126984126984;
        x2 = x * x;
        before = x * (1.0 - x2 * (s3 + x2 * s5));
        after = x * (1.0 - x2 * (s3 + x2 * (s5 - x2 * s7)));
        d = before - after;
        n = 4.0;
        s = 1.0;
        f = 362880.0;
        x4 = x2 * x2;
        xx = x * x4 * x4;
    }
    while d > 0.0000000000000001 {
        before = after;
        after = after + s * xx / f;
        s = -s;
        xx = xx * x2;
        n = n + 1.0;
        f = f * 2.0 * n * (2.0 * n + 1.0);
        d = before - after;
        if d < 0.0 {
            d = -d;
        }
    }
    return sign * after;
}

def cos(x: float): float {
    let sign = 1.0;
    let pi2 = pi * 2.0;
    if fabs(x) > pi2 {
        x = x % pi2;
    }
    if fabs(x) > pi {
        x = pi2 - x;
    }
    let piHalf = pi * 0.5;
    let rounding_error = 0.0000000000000001;
    if fabs(x) > piHalf {
        sign = -sign;
        x = pi - x + rounding_error;
    }
    if fabs(x) > pi * 0.25 {
        return sign * sin(piHalf - x + rounding_error);
    }
    let {
        c2 = 0.5;
        c4 = 0.041666666666666664;
        c6 = 0.001388888888888889;
        x2 = x * x;
        before = 1.0 - x2 * (c2 - x2 * c4);
        after = 1.0 - x2 * (c2 - x2 * (c4 - x2 * c6));
        d = before - after;
        n = 4.0;
        s = 1.0;
        f = 40320.0;
        x4 = x2 * x2;
        xx = x4 * x4;
    }
    while d > 0.0000000000000001 {
        before = after;
        after = after + s * xx / f;
        s = -s;
        xx = xx * x2;
        n = n + 1.0;
        f = f * 2.0 * n * (2.0 * n - 1.0);
        d = before - after;
        if d < 0.0 {
            d = -d;
        }
    }
    return sign * after;
}

def tan(x: float): float {
    return sin(x) / cos(x);
}

def exp(x: float): float {
    let coeff = [
        1.0,
        0.5,
        0.1666666666666666574148081281236954964697360992431640625,
        0.041666666666666664353702032030923874117434024810791015625,
        0.00833333333333333321768510160154619370587170124053955078125,
        0.00138888888888888894189432843262466121814213693141937255859375,
        0.0001984126984126984125263171154784913596813566982746124267578125,
        0.0000248015873015873015657896394348114199601695872843265533447265625,
        0.000002755731922398589251095059327045788677423843182623386383056640625,
        0.000000275573192239858882757858569989561914326259284280240535736083984375,
        0.0000000250521083854417202238661793213536643776251366944052278995513916015625,
        0.000000002087675698786810018655514943446138698135428057867102324962615966796875,
        0.0000000001605904383682161334086291829494519585452838583705670316703617572784423828125,
        0.00000000001147074559772972450729657045037464453175746204038887299248017370700836181640625
    ];
    let s = round(x);
    let t = x - tofloat(s);
    let es = [
        1.0,
        2.718281828459045090795598298427648842334747314453125,
        7.3890560989306504069418224389664828777313232421875,
        20.08553692318766792368478490971028804779052734375,
        54.59815003314423620395245961844921112060546875,
        148.413159102576599934764089994132518768310546875,
        403.42879349273511024875915609300136566162109375,
        1096.63315842845850056619383394718170166015625,
        2980.9579870417283018468879163265228271484375,
        8103.083927575384223018772900104522705078125,
        22026.465794806717894971370697021484375
    ];
    let ess = [
        1.0,
        0.367879441171442334024277442949824035167694091796875,
        0.13533528323661270231781372785917483270168304443359375,
        0.049787068367863944462481384789498406462371349334716796875,
        0.0183156388887341821380960737997156684286892414093017578125,
        0.00673794699908546700084510661099557182751595973968505859375,
        0.002478752176666358490730868169293898972682654857635498046875,
        0.000911881965554516243747940063002488386700861155986785888671875,
        0.0003354626279025118532235716362066568763111717998981475830078125,
        0.00012340980408667953410924156276706753487815149128437042236328125,
        0.000045399929762484847396881992853678866595146246254444122314453125
    ];
    let exp_s = 1.0;
    let u = 0;
    if s >= 0 {
        u = s / 10;
        while(u > 0) {
            exp_s = exp_s * es[10];
            u = u - 1;
        }
        exp_s = exp_s * es[s % 10];
    }
    else {
        s = -s;
        u = s / 10;
        while(u > 0) {
            exp_s = exp_s * ess[10];
            u = u - 1;
        }
        exp_s = exp_s * ess[s % 10];
    }
    let exp_t = 0.0;
    let t2 = t * t;
    let t4 = t2 * t2;
    let t8 = t4 * t4;
    exp_t = exp_t + t8 * t4 * t2 * coeff[13];
    exp_t = exp_t + t8 * t4 * t * coeff[12];
    exp_t = exp_t + t8 * t4 * coeff[11];
    exp_t = exp_t + t8 * t2 * t * coeff[10];
    exp_t = exp_t + t8 * t2 * coeff[9];
    exp_t = exp_t + t8 * t * coeff[8];
    exp_t = exp_t + t8 * coeff[7];
    exp_t = exp_t + t4 * t2 * t * coeff[6];
    exp_t = exp_t + t4 * t2 * coeff[5];
    exp_t = exp_t + t4 * t * coeff[4];
    exp_t = exp_t + t4 * coeff[3];
    exp_t = exp_t + t2 * t * coeff[2];
    exp_t = exp_t + t2 * coeff[1];
    exp_t = exp_t + t * coeff[0];
    exp_t = exp_t + 1.0;

    return exp_s * exp_t;
}

def sinh(x: float) = (exp(x) - exp(-x)) * 0.5;

def cosh(x: float) = (exp(x) + exp(-x)) * 0.5;

def tanh(x: float) = sinh(x) / cosh(x);

def log10(x: float): float {
    if x <= 0.0 {
        return 0.0;
    }
    let n = 0.0;
    while x < 1.0 {
        x = x * 10.0;
        n = n - 1.0;
    }
    while x >= 10.0 {
        x = x * 0.1;
        n = n + 1.0;
    }
    if x == 1.0 {
        return n;
    }
    let retval = n;
    let add = 0.5;
    while add > 0.0000000000000001 {
        x = x * x;
        if x >= 10.0 {
            retval = retval + add;
            x = x * 0.1;
        }
        add = add * 0.5;
    }
    return retval;
}

def log2(x: float): float {
    return 3.321928094887362 * log10(x);
}

def log(x: float): float {
    return 2.302585092994046 * log10(x);
}

def pow(x: float, y: float): float {
    if x > 0.0 {
        return exp(y * log(x));
    }
    else if x == 0.0 {
        return 0.0;
    }
    else {
        if y == tofloat(floor(y)) {
            if floor(y) % 2 == 0 {
                return exp(y * log(-x));
            }
            else {
                return -exp(y * log(-x));
            }
        }
        else {
            return 0.0;
        }
    }
}

def exp2(x: float) = pow(2.0, x);

def ldexp(x: float, exp: int) = x * pow(2.0, tofloat(exp));

def logb(x: float) = if x == 0.0 0 else floor(log2(x));

def sqrt(x :float): float {
    if x <= 0.0 {
        return 0.0;
    }
    let e = logb(x) + 1;
    let a = pow(2.0, -tofloat(e) * 0.5);
    let error = 1.0;
    let h = 1.0 - x * a * a;
    while fabs(h) < fabs(error) {
        a = a * (1.0 + h * (0.5 + h * 0.375));
        error = h;
        h = 1.0 - x * a * a;
    }
    return a * x;
}

def cbrt(x: float): float {
    if x <= 0.0 {
        return 0.0;
    }
    let e = logb(x) + 1;
    let a = pow(2.0, -tofloat(e) * 0.5);
    let error = 1.0;
    let h = 1.0 - x * a * a * a;
    while fabs(h) < fabs(error) {
        a = a * (1.0 + h * (0.33333333333333333333 + h * 0.22222222222222222222));
        error = h;
        h = 1.0 - x * a * a * a;
    }
    x = x * a;
    e = logb(x) + 1;
    a = pow(2.0, -tofloat(e) * 0.5);
    error = 1.0;
    h = 1.0 - x * a * a;
    while fabs(h) < fabs(error) {
        a = a * (1.0 + h * (0.5 + h * 0.375));
        error = h;
        h = 1.0 - x * a * a;
    }
    return a * x;
}

def hypot(x: float, y: float): float {
    let u = max(fabs(x), fabs(y));
    let v = min(fabs(x), fabs(y));
    return fabs(u) * sqrt(1.0 + (v / u) * (v / u));
}

def asinh(x: float) = log(x + sqrt(x * x + 1.0));

def acosh(x: float) = if x <= 1.0 0.0 else log(x + sqrt(x * x + 1.0));

def asin(x: float): float {
    if x < 0.0 {
        return -asin(-x);
    }
    if x > 1.0 {
        assert x > 1.0;
    }
    if x > 0.7071067811865475 {
        return pi * 0.5 - asin(sqrt(1.0 - x * x));
    }
    let s = [
        1.0,
        0.16666666666666666,
        0.075,
        0.044642857142857144,
        0.030381944444444444,
        0.022372159090909092,
        0.017352764423076924,
        0.01396484375,
        0.011551800896139705,
        0.009761609529194078,
        0.008390335809616815,
        0.0073125258735988454,
        0.006447210311889649,
        0.005740037670841924,
        0.005153309682319905,
        0.004660143486915096,
        0.004240907093679363,
        0.003880964558837669,
        0.0035692053938259347,
        0.003297059503473485,
        0.0030578216492580306,
        0.002846178401108942
    ];
    let {
        s1 = s[1];
        s2 = s[2];
        s3 = s[3];
        x2 = x * x;
        before = x * (1.0 + x2 * (s1 + x2 * s2));
        after = x * (1.0 + x2 * (s1 + x2 * (s2 + x2 * s3)));
        d = after - before;
        x4 = x2 * x2;
        xx = x * x4 * x4;
    }

    let n = 4;
    
    while d != 0.0 && n < 22 {
        before = after;
        after = after + xx * s[n];
        n = n + 1;
        xx = xx * x2;
        d = after - before;
    }
    return after;
}

def acos(x: float): float{
    return pi * 0.5 - asin(x);
}

def atan(x: float): float {
    if x < 0.0 {
        return -atan(-x);
    }
    let rounding_error = 0.0000000000000001;
    if x > 2.414213562373095 {
        return pi * 0.5 - atan(1.0 / x);
    }
    if x > 0.414213562373095 {
        return pi * 0.25 + atan((x - 1.0) / (x + 1.0));
    }
    let {
        before = x;
        after = x - x * x * x * 0.3333333333333333;
        sign = 1.0;
        d = before - after;
        x2 = x * x;
        xx = x * x * x * x2;
        n = 2.0;
    }
    while(d > 0.0000000000000001) {
        before = after;
        after = after + sign * xx / (2.0 * n + 1.0);
        xx = xx * x2;
        sign = -sign;
        n = n + 1.0;
        d = before - after;
        if(d < 0.0) {
            d = -d;
        }
    }
    return after;
}

def lerp(a: float, b: float, t: float) = a + t * (b - a);